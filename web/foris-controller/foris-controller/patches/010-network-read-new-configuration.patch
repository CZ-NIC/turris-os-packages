From 76d545525bb1c17acf7b468686c400881707088a Mon Sep 17 00:00:00 2001
From: Filip Hron <filip.hron@nic.cz>
Date: Mon, 6 Sep 2021 19:50:07 +0200
Subject: [PATCH 01/11] network: enable controller to read new network config

We need to be able to read both regular and new configuration.

+ 10 additional fixups
---
 foris_controller_backends/guest/__init__.py   |    6 +-
 foris_controller_backends/lan/__init__.py     |    1 +
 .../networks/__init__.py                      |  118 +-
 foris_controller_backends/wan/__init__.py     |    6 +-
 11 files changed, 1291 insertions(+), 33 deletions(-)

diff --git a/foris_controller_backends/guest/__init__.py b/foris_controller_backends/guest/__init__.py
index 4ea8936..b6bdf1d 100644
--- a/foris_controller_backends/guest/__init__.py
+++ b/foris_controller_backends/guest/__init__.py
@@ -123,8 +123,12 @@ class GuestUci(object):
         # update network interface list
         backend.add_section("network", "interface", "guest_turris")
         backend.set_option("network", "guest_turris", "enabled", enabled)
-        backend.set_option("network", "guest_turris", "type", "bridge")
+        # backend.set_option("network", "guest_turris", "type", "bridge")
         backend.set_option("network", "guest_turris", "proto", "static")
+        backend.add_section("network", "device", "br_guest")
+        backend.set_option("network", "br_guest", "name", "br-guest")
+        backend.set_option("network", "br_guest", "type", "bridge")
+        backend.set_option("network", "guest_turris", "device", "br-guest")
         if guest_network["enabled"]:
             backend.set_option("network", "guest_turris", "ipaddr", guest_network["ip"])
             backend.set_option("network", "guest_turris", "netmask", guest_network["netmask"])
diff --git a/foris_controller_backends/lan/__init__.py b/foris_controller_backends/lan/__init__.py
index 7745d5c..9395902 100644
--- a/foris_controller_backends/lan/__init__.py
+++ b/foris_controller_backends/lan/__init__.py
@@ -333,6 +333,7 @@ class LanUci(object):
         for record in get_sections_by_type(dhcp_data, "dhcp", "host"):
             if "ip" in record["data"] and record["data"]["ip"] != "ignore":
                 # remove if in dynamic range
+
                 if self.in_range(record["data"]["ip"], new_router_ip, new_start, new_limit):
                     backend.del_section("dhcp", record["name"])
 
diff --git a/foris_controller_backends/networks/__init__.py b/foris_controller_backends/networks/__init__.py
index ae574a8..e123119 100644
--- a/foris_controller_backends/networks/__init__.py
+++ b/foris_controller_backends/networks/__init__.py
@@ -33,6 +33,7 @@ from foris_controller_backends.uci import (
     get_option_named,
     get_sections_by_type,
     parse_bool,
+    section_exists,
     store_bool,
 )
 
@@ -41,12 +42,40 @@ logger = logging.getLogger(__name__)
 
 class NetworksUci(object):
     def _prepare_network(self, data, section, ports_map):
+        # TODO: once `ifname` not required, refactor
         interfaces = get_option_named(data, "network", section, "ifname", [])
         interfaces = interfaces if isinstance(interfaces, (tuple, list)) else interfaces.split(" ")
+        device = get_option_named(data, "network", section, "device", "")
+
+        devices = get_option_named(data,"network", device.replace("-", "_"), "ports", [])
+
+        # by default migrated "br-lan" is anonymous
+        if section == "lan" and len(devices) < 1 and not interfaces:
+            devs = get_sections_by_type(data, "network", "device")
+            lan_bridge = [i for i in filter(
+                lambda x: x["name"].startswith("cfg")
+                and x["data"]["name"] == "br-lan",
+                devs
+            )]
+            devices = lan_bridge[0]["data"].get("ports", [])
         res = []
+
+        # ensure ports are in port_map
+        if devices:
+            for port in devices:
+                if port in ports_map:
+                    res.append(ports_map.pop(port))
+        else:
+            try:
+                res.append(ports_map.pop(device))
+            except KeyError:
+                pass
+
+        # TODO: once old uci not supported delete, see above
         for interface in interfaces:
             if interface in ports_map:
                 res.append(ports_map.pop(interface))
+
         return res
 
     def _find_enabled_networks_by_ifname(self, wireless_data, ifname):
@@ -56,7 +85,7 @@ class NetworksUci(object):
         iface_sections = [
             section
             for section in get_sections_by_type(wireless_data, "wireless", "wifi-iface")
-            if section["data"].get("ifname") == ifname and section["data"].get("device")
+            if section["data"].get("device") == ifname and section["data"].get("device")
         ]
         if not iface_sections:
             return None
@@ -167,7 +196,14 @@ class NetworksUci(object):
                 hw_interfaces = [e for e in turrishw.get_ifaces().keys()]
         except Exception:
             hw_interfaces = []
-        config_interfaces = get_option_named(network_data, "network", network_name, "ifname", [])
+        if get_option_named(network_data, "network", network_name, "ifname", "") != "":
+            config_interfaces = get_option_named(network_data, "network", network_name, "ifname", [])
+        else:
+            device = get_option_named(network_data, "network", network_name, "device", "").replace("-","_")
+            if section_exists(network_data, "network", device):
+                config_interfaces = get_option_named(network_data, "network", device, "ports", [])
+            else:
+                config_interfaces = get_option_named(network_data, "network", network_name, "device", "")
         config_interfaces = (
             config_interfaces
             if isinstance(config_interfaces, (list, tuple))
@@ -275,15 +311,83 @@ class NetworksUci(object):
         # check valid ports
         if {e["id"] for e in ports} != {e for e in wan_ifs + lan_ifs + guest_ifs + none_ifs}:
             # current ports doesn't match the one that are being set
+            print(ports, wan_ifs,lan_ifs, guest_ifs, none_ifs)
             return False
 
+        def _create_bridge(backend, net, ifs, mac=None):
+            """Create bridge device and set its interfaces"""
+            backend.add_section("network", "device", f"br_{net}")
+            backend.set_option("network", f"br_{net}", "name", f"br-{net}")
+            backend.set_option("network", f"br_{net}", "type", "bridge")
+            backend.replace_list("network", f"br_{net}", "ports", ifs)
+            backend.set_option("network", net, "device", f"br-{net}")
+            backend.del_option("network", net, "bridge_empty", fail_on_error=False)
+            if mac:
+                backend.set_option("network", f"br_{net}", "macaddr", mac)
+
+        def _del_bridge(backend, data, net, device):
+            """Delete bridge and set the interface device to device"""
+            mac = get_option_named(data, "network", f"br_{net}", "macaddr", False)
+            if section_exists(data, "network", f"br_{net}"):
+                try:
+                    backend.del_section("network", f"br_{net}")
+                except UciException:
+                    pass
+            if device:
+                backend.set_option("network", net, "device", device[0])
+                if mac:
+                    backend.set_option("network", net, "macaddr", mac)
+            else:
+                backend.del_option("network", net, "device", fail_on_error=False)
+                backend.set_option("network", net, "bridge_empty", store_bool(True))
+
+        def _set_bridge_network(backend, net, ifs):
+            """Set bridge ports to provided interfaces"""
+            backend.replace_list("network", f"br_{net}", "ports", ifs)
+
         with UciBackend() as backend:
+            # enable guest
             GuestUci.enable_guest_network(backend)
-            backend.set_option("network", "wan", "ifname", "" if len(wan_ifs) == 0 else wan_ifs[0])
-            backend.set_option("network", "lan", "bridge_empty", store_bool(True))
-            backend.set_option("network", "lan", "type", "bridge")
-            backend.replace_list("network", "lan", "ifname", lan_ifs)
-            backend.replace_list("network", "guest_turris", "ifname", guest_ifs)
+            data = backend.read("network")
+            backend.replace_list("network", "br_guest", "ports", guest_ifs)
+
+            for net, ifs in zip(("wan", "lan"), (wan_ifs, lan_ifs)):
+                # determine old config and delete it's keys and values
+                if get_option_named(data, "network", net, "ifname", "") != "":
+                    # this is old config, when "ifname" is present
+                    backend.del_option("network", net, "ifname", fail_on_error=False)
+                    if get_option_named(data, "network", net, "type", "") == "bridge":
+                        # it also is of "bridge" type, which is reserved for "device" rather than "interface"
+                        backend.del_option("network", net, "type", fail_on_error=False)
+
+                # Check for anonymous bridge device (this actually applies only to lan)
+                # this is here in case of migrated config with properly set bridge
+                # but the bridge is anonymous.
+                br_name = f"br-{net}"
+                mac = None
+                if get_option_named(data, "network", net, "device", "") == br_name:
+                    devs = enumerate(get_sections_by_type(data, "network", "device"))
+                    # update data with index of config
+                    devs = [{"index": idx, **dev} for idx, dev in devs]
+                    anonymous = [i for i in filter(
+                        lambda x: x["name"].startswith("cfg") and x["data"]["name"] == br_name,
+                        devs
+                    )]
+                    if anonymous:
+                        mac = anonymous[0]["data"].get("macaddr")
+                        idx = anonymous[0]["index"]
+                        backend.del_section("network",f"@device[{idx}]")
+
+                # new configuration
+                if len(ifs) > 1:
+                    # more than one interface should have been used with bridge device
+                    if section_exists(data, "network", f"br_{net}"):
+                        # bridge already exists
+                        _set_bridge_network(backend, net, ifs)
+                    else:
+                        _create_bridge(backend, net, ifs, mac)
+                else:
+                    _del_bridge(backend, data, net, ifs)
 
             def set_firewall_rule(name, enabled, port):
                 # update firewall rules
diff --git a/foris_controller_backends/wan/__init__.py b/foris_controller_backends/wan/__init__.py
index f89911e..0e9d93a 100644
--- a/foris_controller_backends/wan/__init__.py
+++ b/foris_controller_backends/wan/__init__.py
@@ -184,7 +184,7 @@ class WanUci:
             # WAN6
             wan6_type = wan6_settings["wan6_type"]
             backend.add_section("network", "interface", "wan6")
-            backend.set_option("network", "wan6", "ifname", "@wan")
+            backend.set_option("network", "wan6", "device", "@wan")
             backend.set_option("network", "wan6", "proto", wan6_type)
 
             backend.del_option("network", "wan6", "ip6prefix", fail_on_error=False)
@@ -308,11 +308,11 @@ class WanUci:
 
             if qos:
                 network_data = backend.read("network")
-                ifname = get_option_named(network_data, "network", "wan", "ifname")
+                device = get_option_named(network_data, "network", "wan", "device")
                 try:
                     if qos.get("enabled"):
                         backend.add_section("sqm", "queue", WanUci._LNAME)
-                        backend.set_option("sqm", WanUci._LNAME, "interface", ifname)
+                        backend.set_option("sqm", WanUci._LNAME, "interface", device)
                         backend.set_option("sqm", WanUci._LNAME, "download", qos["download"])
                         backend.set_option("sqm", WanUci._LNAME, "upload", qos["upload"])
                         backend.set_option("sqm", WanUci._LNAME, "script", "piece_of_cake.qos")
